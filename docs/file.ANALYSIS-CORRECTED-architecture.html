<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: ANALYSIS-CORRECTED-architecture
  
    &mdash; Documentation by YARD 0.9.38
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" />

  <link rel="stylesheet" href="css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "ANALYSIS-CORRECTED-architecture";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: ANALYSIS-CORRECTED-architecture</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><h1 id="corrected-architecture-tree_haver--citrus-backend">Corrected Architecture: tree_haver + Citrus Backend</h1>

<h2 id="key-correction">Key Correction</h2>

<p><strong>tree_haver remains completely grammar-agnostic!</strong></p>

<p>tree_haver does NOT know about TOML, JSON, YAML, etc.<br>
It only provides:</p>
<ol>
  <li>Unified Node interface</li>
  <li>Backend abstraction (MRI/Rust/FFI/Java/Citrus)</li>
  <li>Generic grammar loading mechanism</li>
</ol>

<h2 id="correct-architecture">Correct Architecture</h2>

<pre class="code ruby"><code class="ruby">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ toml-merge (TOML-SPECIFIC)                                      â”‚
â”‚                                                                  â”‚
â”‚ â€¢ Depends on toml-rb (TOML Citrus grammar)                     â”‚
â”‚ â€¢ Depends on tree_haver (unified interface)                     â”‚
â”‚ â€¢ Provides TOML semantics (table?, key_name, etc.)             â”‚
â”‚ â€¢ Works with ANY tree_haver backend                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â†“
                    Uses tree_haver&#39;s API
                               â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ tree_haver (GRAMMAR-AGNOSTIC)                                   â”‚
â”‚                                                                  â”‚
â”‚ â€¢ Unified Node interface (type, text, children, etc.)          â”‚
â”‚ â€¢ Backend selection (auto, mri, rust, ffi, java, citrus)       â”‚
â”‚ â€¢ Grammar loading abstraction                                   â”‚
â”‚ â€¢ NO knowledge of specific languages                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â†“
              Delegates to selected backend
                               â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                                   â”‚
    â†“                                                   â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Tree-sitter Backendsâ”‚                   â”‚ Citrus Backend       â”‚
â”‚                     â”‚                   â”‚                      â”‚
â”‚ â€¢ MRI               â”‚                   â”‚ â€¢ Generic Citrus     â”‚
â”‚ â€¢ Rust              â”‚                   â”‚   wrapper            â”‚
â”‚ â€¢ FFI               â”‚                   â”‚ â€¢ Accepts any        â”‚
â”‚ â€¢ Java              â”‚                   â”‚   Citrus grammar     â”‚
â”‚                     â”‚                   â”‚ â€¢ NO TOML knowledge  â”‚
â”‚ All use tree-sitter â”‚                   â”‚                      â”‚
â”‚ with language libs  â”‚                   â”‚ Uses Citrus parser   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â†“                                          â†“
  libtree-sitter-toml                      Citrus + grammar module
  (native library)                         (provided by toml-rb)
</code></pre>

<h2 id="what-each-layer-does">What Each Layer Does</h2>

<h3 id="layer-1-tree_haver-generic-parser-interface">Layer 1: tree_haver (Generic Parser Interface)</h3>

<p><strong>Purpose:</strong> Provide unified API across different parsing backends</p>

<p><strong>What it knows:</strong></p>
<ul>
  <li>âœ… How to create Node objects</li>
  <li>âœ… How to traverse ASTs</li>
  <li>âœ… How to extract positions/text</li>
  <li>âœ… How to switch backends</li>
</ul>

<p><strong>What it DOESNâ€™T know:</strong></p>
<ul>
  <li>âŒ TOML syntax</li>
  <li>âŒ What a â€œtableâ€ is</li>
  <li>âŒ What a â€œkey-value pairâ€ is</li>
  <li>âŒ Any language-specific semantics</li>
</ul>

<p><strong>Example tree_haver API:</strong></p>
<pre class="code language-ruby"><code class="language-ruby">parser = TreeHaver::Parser.new
parser.language = some_grammar  # Generic - works with ANY grammar
tree = parser.parse(source)

node = tree.root_node
node.type        # =&gt; :table (just a symbol from grammar)
node.start_byte  # =&gt; 0
node.text        # =&gt; &quot;[section]&quot;
node.children    # =&gt; [...]

# tree_haver doesn&#39;t know what :table means!
# It just provides the data.
</code></pre>

<h3 id="layer-2-toml-merge-toml-semantics">Layer 2: toml-merge (TOML Semantics)</h3>

<p><strong>Purpose:</strong> Understand TOML structure and provide merge logic</p>

<p><strong>What it knows:</strong></p>
<ul>
  <li>âœ… TOML syntax and semantics</li>
  <li>âœ… What :table means (itâ€™s a TOML section)</li>
  <li>âœ… What :keyvalue/:pair means (TOML key-value)</li>
  <li>âœ… How to extract table names</li>
  <li>âœ… How to merge TOML files</li>
</ul>

<p><strong>What it DOESNâ€™T know:</strong></p>
<ul>
  <li>âŒ Which backend tree_haver is using</li>
  <li>âŒ How parsing actually works</li>
  <li>âŒ Tree-sitter vs Citrus details</li>
</ul>

<p><strong>Example toml-merge API:</strong></p>
<pre class="code language-ruby"><code class="language-ruby">analysis = Toml::Merge::FileAnalysis.new(source)
# Internally uses tree_haver, doesn&#39;t care which backend

node = analysis.statements.first
node.table?       # =&gt; true (TOML-specific method)
node.table_name   # =&gt; &quot;section&quot; (TOML-specific extraction)

# toml-merge adds TOML understanding on top of tree_haver!
</code></pre>

<h2 id="backend-comparison">Backend Comparison</h2>

<h3 id="tree-sitter-backends-mrirustffijava">Tree-sitter Backends (MRI/Rust/FFI/Java)</h3>

<pre class="code language-ruby"><code class="language-ruby"># tree_haver loads tree-sitter grammar
TreeHaver::Language.load(&quot;toml&quot;, &quot;/path/to/libtree-sitter-toml.so&quot;)
parser = TreeHaver::Parser.new
parser.language = language
tree = parser.parse(source)

# Returns nodes with types like:
# :table, :pair, :array, :string, etc.
# (from tree-sitter TOML grammar)
</code></pre>

<h3 id="citrus-backend-new">Citrus Backend (NEW)</h3>

<pre class="code language-ruby"><code class="language-ruby"># tree_haver accepts Citrus grammar module
parser = TreeHaver::Parser.new
parser.language = TomlRB::Document  # Citrus grammar module
tree = parser.parse(source)

# Returns nodes with types like:
# :table, :keyvalue, :array, :string, etc.
# (from Citrus TOML grammar - slightly different names!)
</code></pre>

<h2 id="key-design-principle">Key Design Principle</h2>

<p><strong>tree_haver provides transport, toml-merge provides interpretation</strong></p>

<h3 id="analogy-http-vs-web-application">Analogy: HTTP vs Web Application</h3>

<pre class="code ruby"><code class="ruby">HTTP (tree_haver):
  - Transports bytes
  - Doesn&#39;t know about JSON, HTML, etc.
  - Just provides: headers, body, status

Web App (toml-merge):
  - Interprets JSON/HTML
  - Knows what data means
  - Uses HTTP for transport
</code></pre>

<p>Same with parsing:</p>

<pre class="code ruby"><code class="ruby">tree_haver:
  - Transports AST nodes
  - Doesn&#39;t know about TOML, JSON, etc.
  - Just provides: type, text, children

toml-merge:
  - Interprets TOML structure
  - Knows what nodes mean
  - Uses tree_haver for parsing
</code></pre>

<h2 id="implementation-plan---updated">Implementation Plan - UPDATED</h2>

<h3 id="phase-1-refactor-to-use-tree_haver-this-first">Phase 1: Refactor to use tree_haver (THIS FIRST!)</h3>

<p><strong>Goal:</strong> Make toml-merge use tree_haverâ€™s existing backends</p>

<pre class="code language-ruby"><code class="language-ruby"># BEFORE: Direct tree-sitter usage
require &quot;tree_sitter&quot;
language = TreeSitter::Language.load(...)
parser = TreeSitter::Parser.new
parser.language = language

# AFTER: Use tree_haver
require &quot;tree_haver&quot;
# tree_haver auto-detects best backend (MRI/Rust/FFI/Java)
# and handles language loading via GrammarFinder
parser = TreeHaver::Parser.new
parser.language = TreeHaver::Language.toml
</code></pre>

<p><strong>Changes needed:</strong></p>
<ol>
  <li>Update FileAnalysis to use TreeHaver::Parser</li>
  <li>Update NodeWrapper to work with TreeHaver::Node</li>
  <li>Remove direct tree-sitter references</li>
  <li>Add tree_haver dependency</li>
  <li>Test with all tree_haver backends</li>
</ol>

<p><strong>Benefits:</strong></p>
<ul>
  <li>âœ… Works on JRuby (via FFI or Java backend)</li>
  <li>âœ… Works on TruffleRuby (via FFI)</li>
  <li>âœ… Can use Rust backend (tree_stump)</li>
  <li>âœ… Automatically picks best backend</li>
  <li>âœ… Sets foundation for Citrus backend</li>
</ul>

<h3 id="phase-2-add-citrus-backend-to-tree_haver">Phase 2: Add Citrus backend to tree_haver</h3>

<p><strong>Goal:</strong> Add Citrus as another backend option in tree_haver</p>

<p><strong>In tree_haver:</strong></p>
<pre class="code language-ruby"><code class="language-ruby"># tree_haver/lib/tree_haver/backends/citrus.rb
module TreeHaver::Backends
  module Citrus
    class Node
      def initialize(match, source)
        @match = match  # Generic Citrus::Match
        @source = source
      end
      
      def type
        # Extract from events[0] - GENERIC
        @match.events.first.is_a?(Symbol) ? @match.events.first : :unknown
      end
      
      def start_byte; @match.offset; end
      def end_byte; @match.offset + @match.length; end
      def start_point; calculate_point(@match.offset); end
      def end_point; calculate_point(@match.offset + @match.length); end
      def text; @match.string; end
      
      def children
        @match.matches.map { |m| Node.new(m, @source) }
      end
      
      # NO TOML KNOWLEDGE!
    end
    
    class Parser
      def initialize
        @grammar = nil
      end
      
      # Accept any Citrus grammar module
      def language=(grammar_module)
        unless grammar_module.respond_to?(:parse)
          raise ArgumentError, &quot;Grammar must respond to :parse&quot;
        end
        @grammar = grammar_module
      end
      
      def parse(source)
        raise &quot;No grammar loaded&quot; unless @grammar
        
        begin
          parsed = @grammar.parse(source)
          Tree.new(parsed, source)
        rescue Citrus::ParseError =&gt; e
          raise TreeHaver::ParseError, e.message
        end
      end
    end
    
    class Tree
      def initialize(citrus_match, source)
        @root = Node.new(citrus_match, source)
      end
      
      def root_node
        @root
      end
    end
    
    def self.available?
      require &quot;citrus&quot;
      true
    rescue LoadError
      false
    end
    
    def self.capabilities
      {
        backend: :citrus,
        parse: true,
        query: false,  # Citrus doesn&#39;t have query API
        bytes_field: true,
        incremental: false,
      }
    end
  end
end
</code></pre>

<h3 id="phase-3-make-toml-merge-work-with-citrus-backend">Phase 3: Make toml-merge work with Citrus backend</h3>

<p><strong>Goal:</strong> toml-merge automatically works when tree_haver uses Citrus</p>

<p><strong>In toml-merge:</strong></p>
<pre class="code language-ruby"><code class="language-ruby"># Gemfile
gem &quot;tree_haver&quot;
gem &quot;toml-rb&quot;, optional: true  # Only needed for Citrus backend

# lib/toml/merge/file_analysis.rb
class FileAnalysis
  def initialize(source, **options)
    @source = source
    @parser = TreeHaver::Parser.new
    
    # Load appropriate grammar based on backend
    case TreeHaver.backend_module
    when TreeHaver::Backends::Citrus
      # Citrus backend: load toml-rb grammar
      require &quot;toml-rb&quot;
      @parser.language = TomlRB::Document
    else
      # Tree-sitter backends: use registered TOML language
      @parser.language = TreeHaver::Language.toml
    end
    
    @tree = @parser.parse(source)
    # ... rest works the same!
  end
end

# lib/toml/merge/node_wrapper.rb
class NodeWrapper
  def initialize(node, **options)
    @node = node  # TreeHaver::Node (works with any backend!)
    # ... TOML-specific logic
  end
  
  def table?
    # Handle slight differences in type names
    case @node.type
    when :table
      true
    when :array_of_tables, :table_array
      false  # Different type
    else
      false
    end
  end
  
  def table_name
    return unless table?
    
    # Extract from node structure - works with both backends!
    # tree-sitter and Citrus might have slightly different structures
    # but both expose :table type with name information
    extract_table_name_from_node(@node)
  end
end
</code></pre>

<h2 id="type-name-mapping">Type Name Mapping</h2>

<p>The main challenge: tree-sitter and Citrus use slightly different names</p>

<h3 id="tree-sitter-toml-grammar">Tree-sitter TOML grammar:</h3>
<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_table'>table</span>              <span class='lbracket'>[</span><span class='id identifier rubyid_section'>section</span><span class='rbracket'>]</span>
<span class='id identifier rubyid_array_of_tables'>array_of_tables</span>    <span class='lbracket'>[</span><span class='lbracket'>[</span><span class='id identifier rubyid_items'>items</span><span class='rbracket'>]</span><span class='rbracket'>]</span>
<span class='id identifier rubyid_pair'>pair</span>               <span class='id identifier rubyid_key'>key</span> <span class='op'>=</span> <span class='id identifier rubyid_value'>value</span>
<span class='id identifier rubyid_string'>string</span>             <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>value</span><span class='tstring_end'>&quot;</span></span>
<span class='id identifier rubyid_integer'>integer</span>            <span class='int'>42</span>
<span class='id identifier rubyid_array'>array</span>              <span class='lbracket'>[</span><span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span><span class='comma'>,</span> <span class='int'>3</span><span class='rbracket'>]</span>
</code></pre>

<h3 id="citrus-toml-grammar-toml-rb">Citrus TOML grammar (toml-rb):</h3>
<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_table'>table</span>              <span class='lbracket'>[</span><span class='id identifier rubyid_section'>section</span><span class='rbracket'>]</span>
<span class='id identifier rubyid_table_array'>table_array</span>        <span class='lbracket'>[</span><span class='lbracket'>[</span><span class='id identifier rubyid_items'>items</span><span class='rbracket'>]</span><span class='rbracket'>]</span>
<span class='id identifier rubyid_keyvalue'>keyvalue</span>           <span class='id identifier rubyid_key'>key</span> <span class='op'>=</span> <span class='id identifier rubyid_value'>value</span>
<span class='id identifier rubyid_basic_string'>basic_string</span>       <span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>value</span><span class='tstring_end'>&quot;</span></span>
<span class='id identifier rubyid_integer'>integer</span>            <span class='int'>42</span>
<span class='id identifier rubyid_array'>array</span>              <span class='lbracket'>[</span><span class='int'>1</span><span class='comma'>,</span> <span class='int'>2</span><span class='comma'>,</span> <span class='int'>3</span><span class='rbracket'>]</span>
</code></pre>

<h3 id="solution-in-toml-merge">Solution in toml-merge:</h3>

<pre class="code language-ruby"><code class="language-ruby">def normalize_type(type)
  case type
  when :keyvalue then :pair
  when :table_array then :array_of_tables
  when :basic_string, :literal_string then :string
  else type
  end
end
</code></pre>

<h2 id="dependencies">Dependencies</h2>

<h3 id="tree_haver">tree_haver</h3>
<pre class="code language-ruby"><code class="language-ruby"># tree_haver.gemspec
spec.add_dependency &quot;citrus&quot;, &quot;~&gt; 3.0&quot;  # For Citrus backend

# All backends are optional:
# - ruby_tree_sitter (MRI)
# - tree_stump (Rust)
# - ffi (FFI)
# - java-tree-sitter (Java)
# - citrus (Citrus)

# tree_haver picks best available
</code></pre>

<h3 id="toml-merge">toml-merge</h3>
<pre class="code language-ruby"><code class="language-ruby"># toml-merge.gemspec
spec.add_dependency &quot;tree_haver&quot;, &quot;~&gt; 1.0&quot;
spec.add_dependency &quot;toml-rb&quot;, &quot;~&gt; 3.0&quot;  # For Citrus grammar

# toml-rb provides:
# 1. TOML Citrus grammar (TomlRB::Document)
# 2. Semantic layer (TomlRB::Table, etc.) - we might use this
</code></pre>

<h2 id="usage-examples">Usage Examples</h2>

<h3 id="auto-select-default">Auto-select (default)</h3>
<pre class="code language-ruby"><code class="language-ruby">require &quot;toml-merge&quot;

# tree_haver picks best backend:
# - MRI: ruby_tree_sitter (if available)
# - Rust: tree_stump (if available)
# - JRuby: java-tree-sitter or FFI
# - Fallback: Citrus (pure Ruby)

analysis = Toml::Merge::FileAnalysis.new(source)
</code></pre>

<h3 id="force-citrus-pure-ruby">Force Citrus (pure Ruby)</h3>
<pre class="code language-ruby"><code class="language-ruby">require &quot;toml-merge&quot;

TreeHaver.backend = :citrus
analysis = Toml::Merge::FileAnalysis.new(source)
</code></pre>

<h3 id="environment-variable">Environment variable</h3>
<pre class="code language-bash"><code class="language-bash">export TREE_HAVER_BACKEND=citrus
ruby my_script.rb
</code></pre>

<h2 id="benefits-of-this-architecture">Benefits of This Architecture</h2>

<h3 id="1-clean-separation">1. Clean Separation</h3>
<ul>
  <li>tree_haver: Generic parsing mechanics</li>
  <li>toml-merge: TOML-specific semantics</li>
  <li>No grammar knowledge in tree_haver!</li>
</ul>

<h3 id="2-reusability">2. Reusability</h3>
<ul>
  <li>tree_haverâ€™s Citrus backend works for ANY Citrus grammar</li>
  <li>json-merge could use it with a JSON Citrus grammar</li>
  <li>yaml-merge could use it with a YAML Citrus grammar</li>
  <li>bash-merge could use it with a Bash Citrus grammar</li>
</ul>

<h3 id="3-flexibility">3. Flexibility</h3>
<ul>
  <li>toml-merge works with ALL tree_haver backends</li>
  <li>Users can choose backend based on their needs</li>
  <li>Graceful fallback to pure Ruby</li>
</ul>

<h3 id="4-maintainability">4. Maintainability</h3>
<ul>
  <li>tree_haver handles parsing infrastructure</li>
  <li>toml-merge focuses on TOML logic</li>
  <li>Clear boundaries</li>
</ul>

<h2 id="what-gets-built-where">What Gets Built Where</h2>

<h3 id="tree_haver-gains">tree_haver gains:</h3>
<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_lib'>lib</span><span class='op'>/</span><span class='id identifier rubyid_tree_haver'>tree_haver</span><span class='op'>/</span><span class='id identifier rubyid_backends'>backends</span><span class='op'>/</span>
  <span class='id identifier rubyid_citrus'>citrus</span><span class='op'>/</span>
    <span class='id identifier rubyid_node'>node</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>         <span class='comment'># Generic Citrus::Match wrapper
</span>    <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>       <span class='comment'># Generic grammar loading
</span>    <span class='id identifier rubyid_tree'>tree</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>         <span class='comment'># Tree structure
</span>    <span class='id identifier rubyid_point'>point</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>        <span class='comment'># Position calculation
</span></code></pre>

<h3 id="toml-merge-keeps">toml-merge keeps:</h3>
<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_lib'>lib</span><span class='op'>/</span><span class='id identifier rubyid_toml'>toml</span><span class='op'>/</span><span class='id identifier rubyid_merge'>merge</span><span class='op'>/</span>
  <span class='id identifier rubyid_file_analysis'>file_analysis</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>     <span class='comment'># Uses TreeHaver::Parser
</span>  <span class='id identifier rubyid_node_wrapper'>node_wrapper</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>      <span class='comment'># TOML semantics on TreeHaver::Node
</span>  <span class='id identifier rubyid_smart_merger'>smart_merger</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>      <span class='comment'># TOML merge logic
</span>  <span class='id identifier rubyid_conflict_resolver'>conflict_resolver</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span> <span class='comment'># TOML conflict handling
</span></code></pre>

<h2 id="summary">Summary</h2>

<p><strong>Key Points:</strong></p>

<ol>
  <li>âœ… tree_haver remains grammar-agnostic</li>
  <li>âœ… Citrus backend in tree_haver is generic (no TOML knowledge)</li>
  <li>âœ… toml-merge provides TOML-specific logic (works with any backend)</li>
  <li>âœ… toml-rb provides the TOML Citrus grammar</li>
  <li>âœ… Architecture is clean and reusable</li>
</ol>

<p><strong>Implementation Order:</strong></p>

<ol>
  <li>
<strong>FIRST:</strong> Refactor toml-merge to use tree_haver (replace direct tree-sitter)</li>
  <li>
<strong>SECOND:</strong> Add Citrus backend to tree_haver (generic wrapper)</li>
  <li>
<strong>THIRD:</strong> Ensure toml-merge works with Citrus backend</li>
</ol>

<p>This is the correct architecture! ğŸ¯</p>
</div></div>

      <div id="footer">
  Generated on Fri Dec 19 07:47:38 2025 by
  <a href="https://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.38 (ruby-3.4.7).
</div>

    </div>
  </body>
</html>