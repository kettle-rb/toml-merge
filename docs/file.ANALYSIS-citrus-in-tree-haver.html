<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: ANALYSIS-citrus-in-tree-haver
  
    &mdash; Documentation by YARD 0.9.38
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" />

  <link rel="stylesheet" href="css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "ANALYSIS-citrus-in-tree-haver";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: ANALYSIS-citrus-in-tree-haver</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><h1 id="generic-citrus-backend-in-tree_haver---extended-feasibility-analysis">Generic Citrus Backend in tree_haver - Extended Feasibility Analysis</h1>

<h2 id="executive-summary">Executive Summary</h2>

<p>After deep investigation, my recommendation has <strong>CHANGED</strong>:</p>

<p><strong>YES, tree_haver SHOULD include a generic Citrus backend</strong>, but with careful scoping.</p>

<h2 id="key-discovery-the-events-array">Key Discovery: The <code>events</code> Array</h2>

<p>Citrus::Match objects have an <code>events</code> array where <strong><code>events[0]</code> is the rule name</strong> (as a Symbol).</p>

<pre class="code language-ruby"><code class="language-ruby">match.events.first  # =&gt; :table, :keyvalue, :string, etc.
</code></pre>

<p>This provides a <strong>grammar-agnostic type system</strong> that we were missing!</p>

<h2 id="what-tree_haver-can-provide-generically">What tree_haver CAN Provide Generically</h2>

<h3 id="layer-1-generic-citrus-mechanics-tree_haver">Layer 1: Generic Citrus Mechanics (tree_haver)</h3>

<pre class="code language-ruby"><code class="language-ruby">module TreeHaver::Backends::Citrus
  class Node
    def type
      @match.events.first  # Rule name as Symbol
    end
    
    def start_byte
      @match.offset
    end
    
    def end_byte  
      @match.offset + @match.length
    end
    
    def start_point
      # Calculate row/col from offset
      calculate_position(@match.offset)
    end
    
    def end_point
      calculate_position(@match.offset + @match.length)
    end
    
    def text
      @match.string
    end
    
    def children
      @match.matches.map { |m| Node.new(m) }
    end
    
    def captures
      @match.captures
    end
  end
end
</code></pre>

<h3 id="layer-2-language-semantics-toml-merge-json-merge-etc">Layer 2: Language Semantics (toml-merge, json-merge, etc.)</h3>

<p>Each *-merge gem adds semantic understanding:</p>

<pre class="code language-ruby"><code class="language-ruby"># In toml-merge
class Toml::Merge::NodeWrapper
  def initialize(node, backend:)
    case backend
    when :tree_sitter
      @adapter = TreeSitterAdapter.new(node)
    when :citrus
      @adapter = CitrusAdapter.new(node)  # Uses tree_haver&#39;s generic backend
    end
  end
  
  def table?
    case @backend
    when :tree_sitter
      @adapter.type == :table
    when :citrus
      @adapter.type == :table  # Same rule name!
    end
  end
end
</code></pre>

<h2 id="comparison-before-vs-after-discovery">Comparison: Before vs After Discovery</h2>

<h3 id="before-no-type-info">BEFORE (No type info):</h3>
<pre class="code ruby"><code class="ruby">❌ tree_haver: Can&#39;t provide types generically
✓ toml-merge: Must handle ALL Citrus mechanics + TOML semantics
   - Position tracking
   - Line calculation  
   - Type inference from value objects
   - TOML-specific logic
</code></pre>

<h3 id="after-with-events0">AFTER (With events[0]):</h3>
<pre class="code ruby"><code class="ruby">✓ tree_haver: Provides generic Citrus Node with types
   - Rule names as types (events[0])
   - Position tracking
   - Line/column calculation
   - Child traversal
   
✓ toml-merge: Focuses only on TOML semantics
   - Maps rule names to TOML concepts
   - table rule → Table semantics
   - keyvalue rule → Pair semantics
</code></pre>

<h2 id="architecture-recommendation">Architecture Recommendation</h2>

<h3 id="option-a-citrus-backend-in-tree_haver--recommended">Option A: Citrus Backend in tree_haver ⭐ RECOMMENDED</h3>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_tree_haver'>tree_haver</span><span class='op'>/</span>
  <span class='id identifier rubyid_backends'>backends</span><span class='op'>/</span>
    <span class='id identifier rubyid_citrus'>citrus</span><span class='op'>/</span>
      <span class='id identifier rubyid_node'>node</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>           <span class='comment'># Generic Citrus::Match wrapper
</span>      <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>         <span class='comment'># Grammar loading and parsing
</span>      <span class='id identifier rubyid_language'>language</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>       <span class='comment'># Grammar registration
</span>      <span class='id identifier rubyid_point'>point</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>          <span class='comment'># Position (row/col) calculation
</span>      
<span class='id identifier rubyid_toml'>toml</span><span class='op'>-</span><span class='id identifier rubyid_merge'>merge</span><span class='op'>/</span>
  <span class='id identifier rubyid_backends'>backends</span><span class='op'>/</span>
    <span class='id identifier rubyid_citrus'>citrus</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>           <span class='comment'># Thin adapter using tree_haver
</span>      <span class='comment'># Maps tree_haver Citrus nodes to TOML semantics
</span>      <span class='comment'># Minimal code - just semantic mappings
</span></code></pre>

<p><strong>Benefits:</strong></p>
<ul>
  <li>✅ tree_haver handles all Citrus mechanics</li>
  <li>✅ toml-merge focuses on TOML semantics only</li>
  <li>✅ Other *-merge gems can reuse tree_haver’s Citrus backend</li>
  <li>✅ Consistent API across all backends (MRI, Rust, FFI, Citrus)</li>
  <li>✅ Better separation of concerns</li>
</ul>

<p><strong>Tradeoffs:</strong></p>
<ul>
  <li>More complexity in tree_haver (new backend to maintain)</li>
  <li>But: If toml-merge proves Citrus is valuable, worth it</li>
  <li>But: Provides foundation for future Citrus-based grammars</li>
</ul>

<h3 id="option-b-citrus-backend-only-in-toml-merge">Option B: Citrus Backend Only in toml-merge</h3>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_toml'>toml</span><span class='op'>-</span><span class='id identifier rubyid_merge'>merge</span><span class='op'>/</span>
  <span class='id identifier rubyid_backends'>backends</span><span class='op'>/</span>
    <span class='id identifier rubyid_citrus'>citrus</span><span class='op'>/</span>
      <span class='id identifier rubyid_match_wrapper'>match_wrapper</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>  <span class='comment'># Wraps Citrus::Match
</span>      <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>         <span class='comment'># Parsing logic
</span>      <span class='id identifier rubyid_node_adapter'>node_adapter</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>   <span class='comment'># Full AST interface + TOML semantics
</span></code></pre>

<p><strong>Benefits:</strong></p>
<ul>
  <li>✅ Keeps tree_haver simpler</li>
  <li>✅ Faster to implement initially</li>
  <li>✅ Can validate pattern before extraction</li>
</ul>

<p><strong>Tradeoffs:</strong></p>
<ul>
  <li>More code in toml-merge</li>
  <li>Duplication if other *-merge gems want Citrus</li>
  <li>Harder to extract later</li>
</ul>

<h2 id="recommended-approach-staged-implementation">Recommended Approach: Staged Implementation</h2>

<h3 id="phase-1-validate-in-toml-merge-first">Phase 1: Validate in toml-merge (FIRST)</h3>
<ol>
  <li>Build complete Citrus backend in toml-merge</li>
  <li>Get it working and tested</li>
  <li>Validate the approach with real usage</li>
  <li>Document what’s generic vs TOML-specific</li>
</ol>

<h3 id="phase-2-extract-to-tree_haver-after-validation">Phase 2: Extract to tree_haver (AFTER validation)</h3>
<ol>
  <li>Identify truly generic Citrus handling</li>
  <li>Move generic parts to tree_haver/backends/citrus</li>
  <li>Keep TOML-specific parts in toml-merge</li>
  <li>Update toml-merge to use tree_haver’s Citrus backend</li>
</ol>

<h3 id="phase-3-polish-and-document-final">Phase 3: Polish and document (FINAL)</h3>
<ol>
  <li>Add examples and documentation</li>
  <li>Make it easy for other *-merge gems to adopt</li>
  <li>Document grammar requirements</li>
</ol>

<h2 id="what-makes-this-feasible-now">What Makes This Feasible Now</h2>

<h3 id="the-events0-discovery">The <code>events[0]</code> Discovery:</h3>
<ul>
  <li>✅ Provides rule names as types</li>
  <li>✅ Works for ANY Citrus grammar</li>
  <li>✅ Allows generic Node implementation</li>
  <li>✅ Maps cleanly to tree-sitter’s type concept</li>
</ul>

<h3 id="position-information">Position Information:</h3>
<ul>
  <li>✅ offset and length from Citrus::Match</li>
  <li>✅ Can calculate line/column from offsets</li>
  <li>✅ Can provide both byte and point positions</li>
</ul>

<h3 id="hierarchical-structure">Hierarchical Structure:</h3>
<ul>
  <li>✅ matches array provides children</li>
  <li>✅ captures provides named sub-matches</li>
  <li>✅ Can traverse generically</li>
</ul>

<h2 id="api-compatibility-analysis">API Compatibility Analysis</h2>

<h3 id="tree-sitter-node-api">tree-sitter Node API:</h3>
<pre class="code language-ruby"><code class="language-ruby">node.type          # String/Symbol
node.start_byte    # Integer
node.end_byte      # Integer  
node.start_point   # {row, column}
node.end_point     # {row, column}
node.text          # String
node.children      # Array&lt;Node&gt;
node.named_children # Array&lt;Node&gt;
node.field(name)   # Node
</code></pre>

<h3 id="citrus-generic-node-proposed">Citrus Generic Node (Proposed):</h3>
<pre class="code language-ruby"><code class="language-ruby">node.type          # Symbol (from events[0])     ✅
node.start_byte    # Integer (from offset)       ✅
node.end_byte      # Integer (offset + length)   ✅
node.start_point   # Calculate from offset       ✅
node.end_point     # Calculate from offset+len   ✅
node.text          # String (from match.string)  ✅
node.children      # Array&lt;Node&gt; (from matches)  ✅
node.named_children # Filter children            ✅ (can implement)
node.field(name)   # From captures[name]         ✅
</code></pre>

<p><strong>Compatibility: 95%</strong> - Close enough for tree_haver abstraction!</p>

<h2 id="grammar-requirements">Grammar Requirements</h2>

<p>For a Citrus grammar to work with tree_haver’s generic backend:</p>

<ol>
  <li>
<strong>Must use Citrus PEG syntax</strong> - .citrus files</li>
  <li>
<strong>Rule names become types</strong> - Use meaningful names</li>
  <li>
<strong>Optional semantic layer</strong> - Can add custom classes like toml-rb does</li>
  <li>
<strong>No special requirements</strong> - Events array is automatic</li>
</ol>

<h3 id="example-hypothetical-json-grammar">Example: Hypothetical JSON grammar</h3>

<pre class="code language-citrus"><code class="language-citrus">grammar JSON::Document
  rule object
    (&#39;{&#39; (pair (&#39;,&#39; pair)*)? &#39;}&#39;) &lt;JSON::ObjectParser&gt;
  end
  
  rule array
    (&#39;[&#39; (value (&#39;,&#39; value)*)? &#39;]&#39;) &lt;JSON::ArrayParser&gt;
  end
  
  rule pair
    (string &#39;:&#39; value) &lt;JSON::PairParser&gt;
  end
end
</code></pre>

<p>With tree_haver’s Citrus backend:</p>
<pre class="code language-ruby"><code class="language-ruby">node.type  # =&gt; :object, :array, :pair
# Language-specific semantics in json-merge, not tree_haver
</code></pre>

<h2 id="other-citrus-grammars-in-the-wild">Other Citrus Grammars in the Wild</h2>

<p>Research shows Citrus is <strong>underutilized</strong>:</p>
<ul>
  <li>✅ <strong>toml-rb</strong> - Active, maintained, production-ready</li>
  <li>❓ Others - Few public Citrus grammar projects found</li>
</ul>

<p><strong>Implication:</strong></p>
<ul>
  <li>This would be <strong>pioneering work</strong>
</li>
  <li>Could encourage more Citrus adoption</li>
  <li>Provides foundation for future grammars</li>
  <li>But: Limited existing ecosystem to leverage</li>
</ul>

<h2 id="risk-assessment">Risk Assessment</h2>

<h3 id="risk-1-citrus-maintenance">Risk 1: Citrus Maintenance</h3>
<ul>
  <li>
<strong>Risk:</strong> Citrus gem might not be actively maintained</li>
  <li>
<strong>Check:</strong> Last update, community activity</li>
  <li>
<strong>Mitigation:</strong> It’s pure Ruby, stable, can fork if needed</li>
</ul>

<h3 id="risk-2-performance">Risk 2: Performance</h3>
<ul>
  <li>
<strong>Risk:</strong> Citrus + Ruby slower than tree-sitter + C</li>
  <li>
<strong>Impact:</strong> Medium - acceptable for fallback backend</li>
  <li>
<strong>Mitigation:</strong> Keep tree-sitter as default, Citrus as fallback</li>
</ul>

<h3 id="risk-3-grammar-compatibility">Risk 3: Grammar Compatibility</h3>
<ul>
  <li>
<strong>Risk:</strong> Not all Citrus grammars may work well</li>
  <li>
<strong>Impact:</strong> Low - can document requirements</li>
  <li>
<strong>Mitigation:</strong> Test with toml-rb first, learn patterns</li>
</ul>

<h3 id="risk-4-maintenance-burden">Risk 4: Maintenance Burden</h3>
<ul>
  <li>
<strong>Risk:</strong> Another backend to maintain in tree_haver</li>
  <li>
<strong>Impact:</strong> Medium - more test surface</li>
  <li>
<strong>Mitigation:</strong> Staged approach (validate in toml-merge first)</li>
</ul>

<h2 id="value-proposition">Value Proposition</h2>

<h3 id="for-tree_haver">For tree_haver:</h3>
<ul>
  <li>✅ Provides pure-Ruby fallback for ANY grammar</li>
  <li>✅ Completes the backend story (native + FFI + pure Ruby)</li>
  <li>✅ Pioneering work in Ruby parsing abstraction</li>
  <li>✅ Foundation for future Citrus grammar ecosystem</li>
</ul>

<h3 id="for-toml-merge">For toml-merge:</h3>
<ul>
  <li>✅ Simpler codebase (delegates to tree_haver)</li>
  <li>✅ Focuses on TOML semantics only</li>
  <li>✅ Consistent with tree_haver’s design</li>
  <li>✅ Easy to maintain</li>
</ul>

<h3 id="for-other--merge-gems">For Other *-merge gems:</h3>
<ul>
  <li>✅ Can create Citrus grammars for their formats</li>
  <li>✅ Reuse tree_haver’s Citrus backend</li>
  <li>✅ Pure Ruby option without native dependencies</li>
  <li>✅ Lower barrier to entry</li>
</ul>

<h2 id="final-recommendation">Final Recommendation</h2>

<h3 id="immediate-now">Immediate (Now):</h3>
<p><strong>Build Citrus backend in toml-merge first</strong></p>
<ul>
  <li>Validate the approach</li>
  <li>Work out edge cases</li>
  <li>Understand generic vs specific boundary</li>
  <li>Get it working in production</li>
</ul>

<h3 id="near-term-after-validation">Near-term (After validation):</h3>
<p><strong>Extract to tree_haver if successful</strong></p>
<ul>
  <li>Move generic Citrus handling to tree_haver</li>
  <li>Document the pattern</li>
  <li>Make it easy for others to adopt</li>
  <li>Publish findings</li>
</ul>

<h3 id="long-term-future">Long-term (Future):</h3>
<p><strong>Encourage Citrus grammar ecosystem</strong></p>
<ul>
  <li>Document how to create grammars for tree_haver</li>
  <li>Support other *-merge gems adopting Citrus</li>
  <li>Build examples (JSON, YAML, etc.)</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p><strong>YES, a generic Citrus backend in tree_haver makes sense, BUT:</strong></p>

<ol>
  <li>
<strong>Validate in toml-merge first</strong> - Don’t prematurely extract</li>
  <li>
<strong>Extract after proving</strong> - Once pattern is solid, move to tree_haver</li>
  <li>
<strong>Document well</strong> - Make it easy for others to follow</li>
</ol>

<p>The discovery of <code>events[0]</code> containing rule names <strong>changes the feasibility</strong> from “limited value” to “solid foundation”. This enables tree_haver to provide a true generic Citrus backend that parallels its tree-sitter backends.</p>

<p><strong>The phased approach reduces risk while enabling the vision.</strong></p>
</div></div>

      <div id="footer">
  Generated on Fri Jan  2 06:07:01 2026 by
  <a href="https://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.38 (ruby-4.0.0).
</div>

    </div>
  </body>
</html>