<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: DECISION-citrus-backend-location
  
    &mdash; Documentation by YARD 0.9.38
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" />

  <link rel="stylesheet" href="css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "DECISION-citrus-backend-location";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: DECISION-citrus-backend-location</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><h1 id="architecture-decision-where-should-citrus-backend-live">Architecture Decision: Where Should Citrus Backend Live?</h1>

<h2 id="tldr-recommendation">TL;DR Recommendation</h2>

<p><strong>Start in toml-merge, extract to tree_haver after validation</strong></p>

<h2 id="key-discovery">Key Discovery</h2>

<p>Citrus::Match objects have an <code>events</code> array where <strong><code>events[0]</code> is the rule name</strong> (Symbol).<br>
This provides a grammar-agnostic type system!</p>

<pre class="code language-ruby"><code class="language-ruby">match.events.first  # =&gt; :table, :keyvalue, :string, etc.
</code></pre>

<p>This changes everything - we CAN build a generic Citrus backend.</p>

<h2 id="three-options-compared">Three Options Compared</h2>

<h3 id="option-1-citrus-backend-only-in-toml-merge">Option 1: Citrus Backend Only in toml-merge</h3>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_toml'>toml</span><span class='op'>-</span><span class='id identifier rubyid_merge'>merge</span><span class='op'>/</span>
  <span class='id identifier rubyid_lib'>lib</span><span class='op'>/</span><span class='id identifier rubyid_toml'>toml</span><span class='op'>/</span><span class='id identifier rubyid_merge'>merge</span><span class='op'>/</span>
    <span class='id identifier rubyid_backends'>backends</span><span class='op'>/</span>
      <span class='id identifier rubyid_tree_sitter'>tree_sitter</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>          <span class='comment'># Existing
</span>      <span class='id identifier rubyid_citrus'>citrus</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>               <span class='comment'># New - full implementation
</span>        <span class='id identifier rubyid_├──'>├──</span> <span class='id identifier rubyid_match_wrapper'>match_wrapper</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>  <span class='comment'># Wraps Citrus::Match
</span>        <span class='id identifier rubyid_├──'>├──</span> <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>         <span class='comment'># Parsing
</span>        <span class='id identifier rubyid_└──'>└──</span> <span class='id identifier rubyid_node_adapter'>node_adapter</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>   <span class='comment'># Full Node interface
</span></code></pre>

<p><strong>Pros:</strong></p>
<ul>
  <li>✅ Fastest to implement</li>
  <li>✅ Keeps tree_haver simple</li>
  <li>✅ Can iterate quickly</li>
  <li>✅ No cross-gem coordination</li>
</ul>

<p><strong>Cons:</strong></p>
<ul>
  <li>❌ All Citrus logic in toml-merge</li>
  <li>❌ Other *-merge gems must duplicate</li>
  <li>❌ Harder to extract later</li>
  <li>❌ Mixing generic + TOML-specific</li>
</ul>

<hr>

<h3 id="option-2-citrus-backend-only-in-tree_haver">Option 2: Citrus Backend Only in tree_haver</h3>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_tree_haver'>tree_haver</span><span class='op'>/</span>
  <span class='id identifier rubyid_lib'>lib</span><span class='op'>/</span><span class='id identifier rubyid_tree_haver'>tree_haver</span><span class='op'>/</span><span class='id identifier rubyid_backends'>backends</span><span class='op'>/</span>
    <span class='id identifier rubyid_citrus'>citrus</span><span class='op'>/</span>
      <span class='id identifier rubyid_node'>node</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>               <span class='comment'># Generic Citrus::Match wrapper
</span>      <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>             <span class='comment'># Parsing
</span>      <span class='id identifier rubyid_language'>language</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>           <span class='comment'># Grammar loading
</span>      <span class='id identifier rubyid_point'>point</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>              <span class='comment'># Position calculation
</span>
<span class='id identifier rubyid_toml'>toml</span><span class='op'>-</span><span class='id identifier rubyid_merge'>merge</span><span class='op'>/</span>
  <span class='id identifier rubyid_lib'>lib</span><span class='op'>/</span><span class='id identifier rubyid_toml'>toml</span><span class='op'>/</span><span class='id identifier rubyid_merge'>merge</span><span class='op'>/</span>
    <span class='id identifier rubyid_backends'>backends</span><span class='op'>/</span>
      <span class='id identifier rubyid_tree_sitter'>tree_sitter</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>        <span class='comment'># Uses tree_haver
</span>      <span class='id identifier rubyid_citrus'>citrus</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>             <span class='comment'># Thin adapter - just TOML semantics
</span></code></pre>

<p><strong>Pros:</strong></p>
<ul>
  <li>✅ Clean separation (generic vs semantic)</li>
  <li>✅ Other *-merge gems can reuse</li>
  <li>✅ Consistent with tree_haver design</li>
  <li>✅ Promotes Citrus ecosystem</li>
</ul>

<p><strong>Cons:</strong></p>
<ul>
  <li>❌ Unproven architecture</li>
  <li>❌ More upfront complexity</li>
  <li>❌ Harder to change if wrong</li>
  <li>❌ Cross-gem coordination needed</li>
</ul>

<hr>

<h3 id="option-3-staged-approach--recommended">Option 3: Staged Approach ⭐ RECOMMENDED</h3>

<p><strong>Phase 1: Build in toml-merge</strong></p>
<pre class="code ruby"><code class="ruby">toml-merge/backends/citrus/
  ├── Full implementation
  └── Clearly marked: generic vs TOML-specific
</code></pre>

<p><strong>Phase 2: Extract to tree_haver (after validation)</strong></p>
<pre class="code ruby"><code class="ruby">tree_haver/backends/citrus/
  └── Generic parts moved here

toml-merge/backends/citrus/  
  └── Only TOML-specific parts remain
</code></pre>

<p><strong>Pros:</strong></p>
<ul>
  <li>✅ ✅ ✅ Low risk - validate before extraction</li>
  <li>✅ Fast initial implementation</li>
  <li>✅ Learn the right boundaries</li>
  <li>✅ Can refine before making it generic</li>
  <li>✅ Benefits of both approaches</li>
</ul>

<p><strong>Cons:</strong></p>
<ul>
  <li>More steps overall</li>
  <li>Temporary duplication during transition</li>
  <li>But: Both cons are temporary!</li>
</ul>

<hr>

<h2 id="decision-matrix">Decision Matrix</h2>

<table>
  <thead>
    <tr>
      <th>Criteria</th>
      <th>Only toml-merge</th>
      <th>Only tree_haver</th>
      <th>Staged</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><strong>Time to first working</strong></td>
      <td>Fast ✅</td>
      <td>Slow ❌</td>
      <td>Fast ✅</td>
    </tr>
    <tr>
      <td><strong>Risk of wrong abstraction</strong></td>
      <td>Low ✅</td>
      <td>High ❌</td>
      <td>Low ✅</td>
    </tr>
    <tr>
      <td><strong>Reusability</strong></td>
      <td>None ❌</td>
      <td>High ✅</td>
      <td>High ✅</td>
    </tr>
    <tr>
      <td><strong>Separation of concerns</strong></td>
      <td>Poor ❌</td>
      <td>Excellent ✅</td>
      <td>Excellent ✅</td>
    </tr>
    <tr>
      <td><strong>Flexibility to iterate</strong></td>
      <td>High ✅</td>
      <td>Low ❌</td>
      <td>High ✅</td>
    </tr>
    <tr>
      <td><strong>Long-term maintenance</strong></td>
      <td>Higher ❌</td>
      <td>Lower ✅</td>
      <td>Lower ✅</td>
    </tr>
    <tr>
      <td><strong>Implementation effort</strong></td>
      <td>Medium</td>
      <td>High</td>
      <td>Medium</td>
    </tr>
  </tbody>
</table>

<p><strong>Winner: Staged Approach</strong> - Best of both worlds</p>

<hr>

<h2 id="implementation-plan-staged-approach">Implementation Plan: Staged Approach</h2>

<h3 id="stage-1-build-in-toml-merge-weeks-1-2">Stage 1: Build in toml-merge (Weeks 1-2)</h3>

<p><strong>Goal:</strong> Get Citrus backend working, learn the patterns</p>

<pre class="code language-ruby"><code class="language-ruby"># lib/toml/merge/backends/citrus.rb
module Toml::Merge::Backends
  module Citrus
    # Mark what&#39;s generic with comments
    class MatchWrapper  # GENERIC - could move to tree_haver
      def initialize(match)
        @match = match
      end
      
      def type
        @match.events.first  # Rule name
      end
      
      def start_byte
        @match.offset
      end
      
      # ... etc - all generic Citrus mechanics
    end
    
    class TomlNodeAdapter  # TOML-SPECIFIC - stays in toml-merge
      def initialize(wrapped_match)
        @wrapped = wrapped_match
      end
      
      def table?
        @wrapped.type == :table
      end
      
      # ... TOML semantics
    end
  end
end
</code></pre>

<p><strong>Deliverables:</strong></p>
<ul>
  <li>Working Citrus backend</li>
  <li>Full test coverage</li>
  <li>Documentation of generic vs specific</li>
  <li>Performance benchmarks</li>
</ul>

<h3 id="stage-2-validate--refine-weeks-3-4">Stage 2: Validate &amp; Refine (Weeks 3-4)</h3>

<p><strong>Goal:</strong> Use in production, find edge cases</p>

<p><strong>Tasks:</strong></p>
<ul>
  <li>Deploy to production</li>
  <li>Gather metrics</li>
  <li>Fix bugs</li>
  <li>Refine boundaries</li>
  <li>Document extraction plan</li>
</ul>

<p><strong>Success Criteria:</strong></p>
<ul>
  <li>All tests passing</li>
  <li>Performance acceptable</li>
  <li>Clear boundary identified</li>
  <li>Ready to extract</li>
</ul>

<h3 id="stage-3-extract-to-tree_haver-weeks-5-6">Stage 3: Extract to tree_haver (Weeks 5-6)</h3>

<p><strong>Goal:</strong> Move generic parts to tree_haver</p>

<pre class="code language-ruby"><code class="language-ruby"># tree_haver/lib/tree_haver/backends/citrus.rb
module TreeHaver::Backends
  module Citrus
    class Node  # Extracted from toml-merge
      # Generic Citrus::Match wrapper
    end
    
    class Parser
      # Generic grammar loading/parsing
    end
  end
end

# toml-merge/lib/toml/merge/backends/citrus.rb
module Toml::Merge::Backends
  module Citrus
    # Now just uses tree_haver + adds TOML semantics
    class Adapter
      def initialize(tree_haver_node)
        @node = tree_haver_node
      end
      
      def table?
        @node.type == :table
      end
      # ... TOML-specific only
    end
  end
end
</code></pre>

<p><strong>Deliverables:</strong></p>
<ul>
  <li>tree_haver gains Citrus backend</li>
  <li>toml-merge simplified</li>
  <li>All tests still passing</li>
  <li>Documentation updated</li>
</ul>

<h3 id="stage-4-polish--document-week-7">Stage 4: Polish &amp; Document (Week 7)</h3>

<p><strong>Goal:</strong> Make it easy for others to use</p>

<p><strong>Tasks:</strong></p>
<ul>
  <li>Write tree_haver Citrus guide</li>
  <li>Document grammar requirements</li>
  <li>Add examples</li>
  <li>Update READMEs</li>
  <li>Blog post/announcement</li>
</ul>

<hr>

<h2 id="what-goes-where-after-extraction">What Goes Where (After Extraction)</h2>

<h3 id="tree_haver-generic-citrus-mechanics">tree_haver (Generic Citrus Mechanics)</h3>

<p><strong>Purpose:</strong> Make ANY Citrus grammar work like tree-sitter</p>

<pre class="code language-ruby"><code class="language-ruby"># Generic capabilities:
- Wrap Citrus::Match
- Extract type from events[0]
- Provide position info (bytes + points)
- Child traversal
- Capture access
- Text extraction
</code></pre>

<p><strong>Example usage:</strong></p>
<pre class="code language-ruby"><code class="language-ruby"># Works with ANY Citrus grammar
language = TreeHaver::Language.from_citrus_grammar(
  path: &quot;path/to/grammar.citrus&quot;,
  grammar_module: MyFormat::Document
)

parser = TreeHaver::Parser.new
parser.language = language
tree = parser.parse(source)

node = tree.root_node
node.type        # =&gt; :object (from grammar rule name)
node.start_byte  # =&gt; 0
node.children    # =&gt; [...]
</code></pre>

<h3 id="toml-merge-toml-semantics">toml-merge (TOML Semantics)</h3>

<p><strong>Purpose:</strong> Understand TOML-specific structure</p>

<pre class="code language-ruby"><code class="language-ruby"># TOML-specific knowledge:
- table rule =&gt; Table semantics
- keyvalue rule =&gt; Pair semantics  
- array rule =&gt; Array semantics
- Comment handling
- Table header extraction
- Key name extraction
- Value parsing
</code></pre>

<p><strong>Example usage:</strong></p>
<pre class="code language-ruby"><code class="language-ruby">analysis = Toml::Merge::FileAnalysis.new(
  source,
  backend: :citrus  # Uses tree_haver&#39;s Citrus backend
)

node = analysis.statements.first
node.table?      # =&gt; true (TOML-specific method)
node.table_name  # =&gt; &quot;section&quot; (TOML-specific)
</code></pre>

<hr>

<h2 id="risk-mitigation">Risk Mitigation</h2>

<h3 id="risk-what-if-we-extract-wrong">Risk: “What if we extract wrong?”</h3>
<p><strong>Mitigation:</strong> Stage 2 validation finds issues before extraction</p>

<h3 id="risk-what-if-boundaries-are-unclear">Risk: “What if boundaries are unclear?”</h3>
<p><strong>Mitigation:</strong> Clear commenting during Stage 1, refined in Stage 2</p>

<h3 id="risk-what-if-no-one-else-uses-citrus">Risk: “What if no one else uses Citrus?”</h3>
<p><strong>Mitigation:</strong> Still valuable for toml-merge portability</p>

<h3 id="risk-what-if-performance-is-bad">Risk: “What if performance is bad?”</h3>
<p><strong>Mitigation:</strong> Measure in Stage 2, optimize before extraction</p>

<hr>

<h2 id="success-metrics">Success Metrics</h2>

<h3 id="stage-1-success">Stage 1 Success:</h3>
<ul class="task-list">
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>Citrus backend passes all toml-merge tests</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>Performance within 2x of tree-sitter</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>Clear generic/specific boundary documented</li>
</ul>

<h3 id="stage-2-success">Stage 2 Success:</h3>
<ul class="task-list">
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>Used in production without issues</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>Edge cases identified and handled</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>Extraction plan documented</li>
</ul>

<h3 id="stage-3-success">Stage 3 Success:</h3>
<ul class="task-list">
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>tree_haver has Citrus backend</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>toml-merge code reduced</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>All tests passing</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>Performance maintained</li>
</ul>

<h3 id="stage-4-success">Stage 4 Success:</h3>
<ul class="task-list">
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>Documentation complete</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>Examples working</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>Other gems can adopt pattern</li>
  <li class="task-list-item">
<input type="checkbox" class="task-list-item-checkbox" disabled>Community feedback positive</li>
</ul>

<hr>

<h2 id="timeline">Timeline</h2>

<pre class="code ruby"><code class="ruby">Week 1-2:  Build in toml-merge
Week 3-4:  Validate &amp; refine
Week 5-6:  Extract to tree_haver
Week 7:    Polish &amp; document
</code></pre>

<p><strong>Total: ~7 weeks to complete architecture</strong></p>

<hr>

<h2 id="conclusion">Conclusion</h2>

<p><strong>Staged approach is the clear winner:</strong></p>

<ol>
  <li>✅ <strong>Low risk</strong> - validate before committing</li>
  <li>✅ <strong>Fast start</strong> - no cross-gem coordination needed</li>
  <li>✅ <strong>Right abstractions</strong> - learn before extracting</li>
  <li>✅ <strong>Long-term benefits</strong> - ends with clean architecture</li>
  <li>✅ <strong>Flexibility</strong> - can stop after Stage 1 if needed</li>
</ol>

<p><strong>Start building the Citrus backend in toml-merge NOW.</strong></p>

<p>Extract to tree_haver once we’ve learned what truly belongs there.</p>

<hr>

<h2 id="next-actions">Next Actions</h2>

<ol>
  <li>Create <code>lib/toml/merge/backends/citrus/</code> directory</li>
  <li>Implement <code>MatchWrapper</code> (generic part)</li>
  <li>Implement <code>TomlNodeAdapter</code> (specific part)</li>
  <li>Add backend selection logic</li>
  <li>Write tests</li>
  <li>Measure performance</li>
</ol>

<p><strong>Let’s start with Stage 1!</strong></p>
</div></div>

      <div id="footer">
  Generated on Thu Feb 19 06:39:57 2026 by
  <a href="https://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.38 (ruby-4.0.1).
</div>

    </div>
  </body>
</html>