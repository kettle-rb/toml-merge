<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: ARCHITECTURE-dual-backend-vision
  
    &mdash; Documentation by YARD 0.9.38
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" />

  <link rel="stylesheet" href="css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "ARCHITECTURE-dual-backend-vision";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: ARCHITECTURE-dual-backend-vision</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><h1 id="architecture-vision-dual-backend-system">Architecture Vision: Dual Backend System</h1>

<h2 id="current-state-tree-sitter-only">Current State (Tree-sitter only)</h2>

<pre class="code ruby"><code class="ruby">toml-merge/
  lib/toml/merge/
    file_analysis.rb        # Directly uses TreeSitter
    node_wrapper.rb         # Wraps TreeSitter::Node
    smart_merger.rb
    conflict_resolver.rb

Dependencies:
  - tree_sitter (gem)
  - libtree-sitter-toml.so (native)
</code></pre>

<p><strong>Problems:</strong></p>
<ul>
  <li>Native library dependency</li>
  <li>Installation can fail</li>
  <li>JRuby incompatible (without complex FFI)</li>
  <li>Limited platform support</li>
</ul>

<hr>

<h2 id="future-state-stage-1-dual-backend-in-toml-merge">Future State: Stage 1 (Dual Backend in toml-merge)</h2>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_toml'>toml</span><span class='op'>-</span><span class='id identifier rubyid_merge'>merge</span><span class='op'>/</span>
  <span class='id identifier rubyid_lib'>lib</span><span class='op'>/</span><span class='id identifier rubyid_toml'>toml</span><span class='op'>/</span><span class='id identifier rubyid_merge'>merge</span><span class='op'>/</span>
    <span class='id identifier rubyid_config'>config</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>                    <span class='comment'># NEW: Backend selection
</span>    <span class='id identifier rubyid_file_analysis'>file_analysis</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>             <span class='comment'># UPDATED: Backend-aware
</span>    <span class='id identifier rubyid_node_wrapper'>node_wrapper</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>              <span class='comment'># UPDATED: Backend-aware
</span>    
    <span class='id identifier rubyid_backends'>backends</span><span class='op'>/</span>                    <span class='comment'># NEW: Backend system
</span>      <span class='id identifier rubyid_backend_adapter'>backend_adapter</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>         <span class='comment'># Abstract interface
</span>      
      <span class='id identifier rubyid_tree_sitter'>tree_sitter</span><span class='op'>/</span>               <span class='comment'># Existing code refactored
</span>        <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>
        <span class='id identifier rubyid_node_adapter'>node_adapter</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>
        
      <span class='id identifier rubyid_citrus'>citrus</span><span class='op'>/</span>                    <span class='comment'># NEW: Pure Ruby backend
</span>        <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>                <span class='comment'># Citrus::Document.parse
</span>        <span class='id identifier rubyid_match_wrapper'>match_wrapper</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>         <span class='comment'># Generic Citrus mechanics (marked)
</span>        <span class='id identifier rubyid_node_adapter'>node_adapter</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>          <span class='comment'># TOML semantics
</span></code></pre>

<p><strong>Usage:</strong></p>
<pre class="code language-ruby"><code class="language-ruby"># Auto-select (prefers tree-sitter)
analysis = FileAnalysis.new(source)

# Force Citrus (pure Ruby)
ENV[&quot;TOML_MERGE_BACKEND&quot;] = &quot;citrus&quot;
analysis = FileAnalysis.new(source)

# Programmatic
Toml::Merge.backend = :citrus
analysis = FileAnalysis.new(source)
</code></pre>

<p><strong>Benefits:</strong></p>
<ul>
  <li>âœ… Works everywhere (fallback to pure Ruby)</li>
  <li>âœ… Graceful degradation</li>
  <li>âœ… No installation failures</li>
</ul>

<hr>

<h2 id="future-state-stage-2-after-extraction">Future State: Stage 2 (After Extraction)</h2>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_tree_haver'>tree_haver</span><span class='op'>/</span>                      <span class='comment'># Generic Citrus support
</span>  <span class='id identifier rubyid_lib'>lib</span><span class='op'>/</span><span class='id identifier rubyid_tree_haver'>tree_haver</span><span class='op'>/</span>
    <span class='id identifier rubyid_backends'>backends</span><span class='op'>/</span>
      <span class='id identifier rubyid_citrus'>citrus</span><span class='op'>/</span>                    <span class='comment'># EXTRACTED: Generic parts
</span>        <span class='id identifier rubyid_node'>node</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>                  <span class='comment'># Generic Citrus::Match wrapper
</span>        <span class='id identifier rubyid_parser'>parser</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>                <span class='comment'># Grammar loading
</span>        <span class='id identifier rubyid_language'>language</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>              <span class='comment'># Grammar registration
</span>        <span class='id identifier rubyid_point'>point</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>                 <span class='comment'># Position calculation
</span>        
<span class='id identifier rubyid_toml'>toml</span><span class='op'>-</span><span class='id identifier rubyid_merge'>merge</span><span class='op'>/</span>                      <span class='comment'># TOML-specific logic
</span>  <span class='id identifier rubyid_lib'>lib</span><span class='op'>/</span><span class='id identifier rubyid_toml'>toml</span><span class='op'>/</span><span class='id identifier rubyid_merge'>merge</span><span class='op'>/</span>
    <span class='id identifier rubyid_backends'>backends</span><span class='op'>/</span>
      <span class='id identifier rubyid_tree_sitter'>tree_sitter</span><span class='op'>/</span>               <span class='comment'># Uses tree_haver (as before)
</span>        <span class='id identifier rubyid_adapter'>adapter</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>
        
      <span class='id identifier rubyid_citrus'>citrus</span><span class='op'>/</span>                    <span class='comment'># SIMPLIFIED: Uses tree_haver
</span>        <span class='id identifier rubyid_adapter'>adapter</span><span class='period'>.</span><span class='id identifier rubyid_rb'>rb</span>               <span class='comment'># Only TOML semantics now!
</span></code></pre>

<p><strong>tree_haver API:</strong></p>
<pre class="code language-ruby"><code class="language-ruby"># Load any Citrus grammar
language = TreeHaver::Language.from_citrus_grammar(
  path: &quot;path/to/grammar.citrus&quot;,
  grammar_module: TomlRB::Document
)

parser = TreeHaver::Parser.new
parser.language = language
tree = parser.parse(source)

# Generic node interface (works for ANY grammar)
node = tree.root_node
node.type        # =&gt; :table (from grammar rule name)
node.start_byte  # =&gt; 0
node.end_byte    # =&gt; 23
node.start_point # =&gt; {row: 0, column: 0}
node.text        # =&gt; &quot;[section]&quot;
node.children    # =&gt; [...]
</code></pre>

<p><strong>toml-merge usage:</strong></p>
<pre class="code language-ruby"><code class="language-ruby"># Same as Stage 1, but implementation simpler
analysis = FileAnalysis.new(source, backend: :citrus)

# Now powered by tree_haver&#39;s generic Citrus backend
node = analysis.statements.first
node.table?      # =&gt; true (TOML-specific method)
node.table_name  # =&gt; &quot;section&quot; (TOML-specific extraction)
</code></pre>

<p><strong>Benefits:</strong></p>
<ul>
  <li>âœ… All Stage 1 benefits</li>
  <li>âœ… Plus: Cleaner code in toml-merge</li>
  <li>âœ… Plus: Other gems can reuse tree_haverâ€™s Citrus backend</li>
  <li>âœ… Plus: Foundation for Citrus grammar ecosystem</li>
</ul>

<hr>

<h2 id="code-examples-how-it-works">Code Examples: How It Works</h2>

<h3 id="stage-1-backend-selection">Stage 1: Backend Selection</h3>

<pre class="code language-ruby"><code class="language-ruby"># config.rb
module Toml::Merge
  class &lt;&lt; self
    def backend
      @backend ||= ENV[&quot;TOML_MERGE_BACKEND&quot;]&amp;.to_sym || :auto
    end
    
    def backend=(name)
      @backend = name&amp;.to_sym
    end
    
    def backend_module
      case backend
      when :tree_sitter
        Backends::TreeSitter
      when :citrus
        Backends::Citrus
      else # :auto
        if Backends::TreeSitter.available?
          Backends::TreeSitter
        elsif Backends::Citrus.available?
          Backends::Citrus
        else
          raise &quot;No TOML parsing backend available&quot;
        end
      end
    end
  end
end
</code></pre>

<h3 id="stage-1-generic-citrus-wrapper-marked-for-extraction">Stage 1: Generic Citrus Wrapper (marked for extraction)</h3>

<pre class="code language-ruby"><code class="language-ruby"># backends/citrus/match_wrapper.rb

# GENERIC - Can move to tree_haver later
module Toml::Merge::Backends::Citrus
  class MatchWrapper
    def initialize(match, source)
      @match = match
      @source = source
    end
    
    # Type from events[0] - GENERIC
    def type
      return :unknown unless @match.respond_to?(:events)
      @match.events.first.is_a?(Symbol) ? @match.events.first : :unknown
    end
    
    # Position info - GENERIC
    def start_byte
      @match.offset
    end
    
    def end_byte
      @match.offset + @match.length
    end
    
    def start_point
      calculate_point(@match.offset)
    end
    
    def end_point
      calculate_point(@match.offset + @match.length)
    end
    
    # Text extraction - GENERIC
    def text
      @match.string
    end
    
    # Child traversal - GENERIC
    def children
      return [] unless @match.respond_to?(:matches)
      @match.matches.map { |m| MatchWrapper.new(m, @source) }
    end
    
    # Captures - GENERIC
    def captures
      @match.captures
    end
    
    private
    
    def calculate_point(offset)
      lines_before = @source[0...offset].count(&quot;\n&quot;)
      line_start = @source.rindex(&quot;\n&quot;, offset - 1) || -1
      column = offset - line_start - 1
      { row: lines_before, column: column }
    end
  end
end
</code></pre>

<h3 id="stage-1-toml-specific-adapter">Stage 1: TOML-Specific Adapter</h3>

<pre class="code language-ruby"><code class="language-ruby"># backends/citrus/node_adapter.rb

# TOML-SPECIFIC - Stays in toml-merge
module Toml::Merge::Backends::Citrus
  class NodeAdapter
    def initialize(wrapped_match)
      @wrapped = wrapped_match
      @match = wrapped_match.instance_variable_get(:@match)
    end
    
    # Delegate generic methods
    def type; @wrapped.type; end
    def start_byte; @wrapped.start_byte; end
    def end_byte; @wrapped.end_byte; end
    def text; @wrapped.text; end
    def children; @wrapped.children.map { |c| NodeAdapter.new(c) }; end
    
    # TOML-specific type checks
    def table?
      type == :table
    end
    
    def array_of_tables?
      type == :table_array
    end
    
    def pair?
      type == :keyvalue
    end
    
    # TOML-specific extraction
    def table_name
      return unless table? || array_of_tables?
      
      # Use toml-rb&#39;s semantic layer
      if @match.respond_to?(:value) &amp;&amp; @match.value.respond_to?(:full_key)
        @match.value.full_key
      end
    end
    
    def key_name
      return unless pair?
      
      if @match.respond_to?(:value) &amp;&amp; @match.value.respond_to?(:dotted_keys)
        @match.value.dotted_keys.join(&quot;.&quot;)
      end
    end
    
    def value_node
      return unless pair?
      
      # Get value from captures
      if @wrapped.captures[:v]
        val_match = @wrapped.captures[:v].first
        NodeAdapter.new(MatchWrapper.new(val_match, @wrapped.instance_variable_get(:@source)))
      end
    end
  end
end
</code></pre>

<h3 id="stage-2-after-extraction-to-tree_haver">Stage 2: After Extraction to tree_haver</h3>

<pre class="code language-ruby"><code class="language-ruby"># tree_haver/lib/tree_haver/backends/citrus/node.rb

module TreeHaver::Backends::Citrus
  class Node
    # Exact same code as MatchWrapper from Stage 1
    # Just moved location!
    
    def initialize(match, source)
      @match = match
      @source = source
    end
    
    def type
      @match.events.first.is_a?(Symbol) ? @match.events.first : :unknown
    end
    
    # ... all the generic methods
  end
end

# toml-merge/lib/toml/merge/backends/citrus/adapter.rb

module Toml::Merge::Backends::Citrus
  class Adapter
    def initialize(tree_haver_node)
      @node = tree_haver_node
      @match = tree_haver_node.instance_variable_get(:@match)
    end
    
    # Delegate generic methods to tree_haver
    def type; @node.type; end
    def start_byte; @node.start_byte; end
    def text; @node.text; end
    # ...
    
    # TOML-specific logic (same as Stage 1)
    def table?; type == :table; end
    def table_name; ... end
    def key_name; ... end
    # ...
  end
end
</code></pre>

<hr>

<h2 id="signature-generation-backend-agnostic">Signature Generation: Backend-Agnostic</h2>

<pre class="code language-ruby"><code class="language-ruby"># node_wrapper.rb (works with both backends)

class NodeWrapper
  def initialize(node, backend:, **options)
    @backend = backend
    
    case backend
    when :tree_sitter
      @adapter = Backends::TreeSitter::NodeAdapter.new(node)
    when :citrus
      @adapter = Backends::Citrus::NodeAdapter.new(node)
    end
  end
  
  def signature
    case @adapter.type
    when :table
      [:table, table_name]
    when :array_of_tables
      [:array_of_tables, table_name]
    when :keyvalue, :pair
      [:pair, key_name]
    # ... etc
    end
  end
  
  # All semantic methods work regardless of backend
  def table?; @adapter.table?; end
  def table_name; @adapter.table_name; end
  def key_name; @adapter.key_name; end
end
</code></pre>

<hr>

<h2 id="fileanalysis-backend-selection">FileAnalysis: Backend Selection</h2>

<pre class="code language-ruby"><code class="language-ruby"># file_analysis.rb

class FileAnalysis
  def initialize(source, backend: nil, **options)
    @source = source
    @backend = backend || Toml::Merge.backend_module
    
    # Parse using selected backend
    @ast = @backend.parse(source)
    @statements = integrate_nodes
  end
  
  private
  
  def integrate_nodes
    case @backend
    when Backends::TreeSitter
      # Existing tree-sitter logic
      integrate_tree_sitter_nodes
    when Backends::Citrus
      # New citrus logic
      integrate_citrus_nodes
    end
  end
  
  def integrate_citrus_nodes
    return [] unless @ast
    
    result = []
    @ast.matches.each do |match|
      next if match.value.nil? # Skip whitespace
      
      wrapper = Backends::Citrus::NodeAdapter.new(
        Backends::Citrus::MatchWrapper.new(match, @source)
      )
      
      result &lt;&lt; NodeWrapper.new(wrapper, backend: :citrus, source: @source)
    end
    
    result.sort_by { |node| node.start_line || 0 }
  end
end
</code></pre>

<hr>

<h2 id="testing-strategy">Testing Strategy</h2>

<h3 id="stage-1-backend-specific-tests">Stage 1: Backend-Specific Tests</h3>

<pre class="code language-ruby"><code class="language-ruby"># spec/toml/merge/backends/tree_sitter_spec.rb
RSpec.describe Toml::Merge::Backends::TreeSitter do
  it &quot;parses TOML correctly&quot; do
    # tree-sitter specific tests
  end
end

# spec/toml/merge/backends/citrus_spec.rb
RSpec.describe Toml::Merge::Backends::Citrus do
  it &quot;parses TOML correctly&quot; do
    # citrus specific tests
  end
end
</code></pre>

<h3 id="stage-1-shared-examples">Stage 1: Shared Examples</h3>

<pre class="code language-ruby"><code class="language-ruby"># spec/toml/merge/backends/shared_examples.rb
RSpec.shared_examples &quot;TOML backend&quot; do |backend_name|
  before do
    Toml::Merge.backend = backend_name
  end
  
  it &quot;parses tables&quot; do
    source = &quot;[section]\nkey = &#39;value&#39;&quot;
    analysis = FileAnalysis.new(source)
    
    expect(analysis.valid?).to be true
    expect(analysis.statements.size).to eq 2
    expect(analysis.statements.first.table?).to be true
  end
  
  it &quot;generates correct signatures&quot; do
    # Test signature generation works with both backends
  end
end

# Run against both backends
RSpec.describe &quot;TreeSitter backend&quot; do
  include_examples &quot;TOML backend&quot;, :tree_sitter
end

RSpec.describe &quot;Citrus backend&quot; do
  include_examples &quot;TOML backend&quot;, :citrus
end
</code></pre>

<hr>

<h2 id="performance-expectations">Performance Expectations</h2>

<h3 id="stage-1-benchmarks">Stage 1 Benchmarks</h3>

<pre class="code language-ruby"><code class="language-ruby"># benchmark/backends_comparison.rb

require &quot;benchmark/ips&quot;

toml_sample = File.read(&quot;fixtures/large.toml&quot;)

Benchmark.ips do |x|
  x.report(&quot;tree-sitter&quot;) do
    Toml::Merge.backend = :tree_sitter
    FileAnalysis.new(toml_sample)
  end
  
  x.report(&quot;citrus&quot;) do
    Toml::Merge.backend = :citrus
    FileAnalysis.new(toml_sample)
  end
  
  x.compare!
end
</code></pre>

<p><strong>Expected Results:</strong></p>
<ul>
  <li>tree-sitter: Faster (native C)</li>
  <li>citrus: 2-5x slower (acceptable for fallback)</li>
</ul>

<p><strong>Acceptable If:</strong></p>
<ul>
  <li>Citrus within 10x of tree-sitter</li>
  <li>Both handle real-world files in &lt; 1 second</li>
</ul>

<hr>

<h2 id="documentation-plan">Documentation Plan</h2>

<h3 id="stage-1-readme-updates">Stage 1 README Updates</h3>

<pre class="code language-markdown"><code class="language-markdown">## Installation

### With tree-sitter (recommended)

Install the tree-sitter TOML parser:

    brew install tree-sitter-toml  # macOS
    apt-get install libtree-sitter-toml  # Linux

Then:

    gem install toml-merge

### Pure Ruby (fallback)

If tree-sitter installation fails, toml-merge automatically
falls back to a pure Ruby parser (slower but works everywhere):

    gem install toml-merge
    # Works out of the box!

### Selecting Backend

```ruby
# Auto (default): prefers tree-sitter, falls back to pure Ruby
analysis = Toml::Merge::FileAnalysis.new(source)

# Force pure Ruby (for JRuby, TruffleRuby, etc.)
ENV[&quot;TOML_MERGE_BACKEND&quot;] = &quot;citrus&quot;
analysis = Toml::Merge::FileAnalysis.new(source)

# Programmatic
Toml::Merge.backend = :citrus
</code></pre>
<pre class="code ruby"><code class="ruby">
---

## Migration Path

### For Existing Users (Stage 1)

**No changes required!**

- tree-sitter backend works exactly as before
- New citrus backend is optional
- Auto-selection is seamless

### For New Users (Stage 1)

**Better experience:**

- Installation &quot;just works&quot; (fallback to pure Ruby)
- No native library troubleshooting
- Works on all platforms

### After Extraction (Stage 2)

**Still no breaking changes!**

- Same API
- Same behavior
- Just cleaner implementation

---

## Success Criteria

### Stage 1 Complete When:
- [x] Citrus backend implemented
- [x] All tests passing with both backends
- [x] Performance measured and acceptable
- [x] Documentation updated
- [x] Generic vs specific boundaries documented

### Stage 2 Complete When:
- [x] Generic code extracted to tree_haver
- [x] toml-merge simplified
- [x] All tests still passing
- [x] Documentation updated
- [x] Example for other *-merge gems

---

## Long-term Vision

### Other *-merge Gems Can Follow

</code></pre>
<p>json-merge/<br>
  backends/<br>
    tree_sitter/      # Native performance<br>
    citrus/           # Pure Ruby via tree_haver</p>

<p>yaml-merge/<br>
  backends/<br>
    tree_sitter/      # Native performance<br>
    citrus/           # Pure Ruby via tree_haver</p>

<p>bash-merge/<br>
  backends/<br>
    tree_sitter/      # Native performance<br>
    citrus/           # Pure Ruby via tree_haver<br>
```</p>

<p><strong>All reuse tree_haverâ€™s infrastructure!</strong></p>

<hr>

<h2 id="conclusion">Conclusion</h2>

<p>This architecture provides:</p>

<ol>
  <li>âœ… <strong>Immediate value</strong> - Pure Ruby fallback for toml-merge</li>
  <li>âœ… <strong>Low risk</strong> - Staged approach validates before extraction</li>
  <li>âœ… <strong>Long-term value</strong> - Foundation for entire *-merge ecosystem</li>
  <li>âœ… <strong>Clean design</strong> - Proper separation of concerns</li>
  <li>âœ… <strong>Backward compatible</strong> - No breaking changes</li>
  <li>âœ… <strong>Future-proof</strong> - Easy to add more backends later</li>
</ol>

<p><strong>Start implementation now!</strong> ðŸš€</p>
</div></div>

      <div id="footer">
  Generated on Thu Feb 19 06:39:57 2026 by
  <a href="https://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.38 (ruby-4.0.1).
</div>

    </div>
  </body>
</html>