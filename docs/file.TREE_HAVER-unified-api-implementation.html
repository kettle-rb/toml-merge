<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: TREE_HAVER-unified-api-implementation
  
    &mdash; Documentation by YARD 0.9.38
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" />

  <link rel="stylesheet" href="css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "TREE_HAVER-unified-api-implementation";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: TREE_HAVER-unified-api-implementation</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><h1 id="treehaver-unified-api---implementation-summary">TreeHaver Unified API - Implementation Summary</h1>

<h2 id="problem-identified">Problem Identified</h2>

<p>TreeHaver was <strong>passing through</strong> backend-specific objects instead of providing a unified API:</p>
<ul>
  <li>MRI backend returned <code>::TreeSitter::Node</code> directly</li>
  <li>Rust backend returned <code>TreeStump::Node</code> directly</li>
  <li>FFI backend returned <code>FFI::Node</code> directly</li>
  <li>Java backend returned <code>Java::Node</code> directly</li>
</ul>

<p>This violated TreeHaver’s core promise: <strong>“write once, run anywhere”</strong></p>

<h2 id="solution-implemented">Solution Implemented</h2>

<p>Created unified wrapper classes that all backends now return:</p>

<h3 id="1-treehavernode-new-file">1. TreeHaver::Node (new file)</h3>
<ul>
  <li>Wraps backend-specific node objects</li>
  <li>Provides consistent API across all backends</li>
  <li>Maps backend differences:
    <ul>
      <li>
<code>node.type</code> (ruby_tree_sitter) → unified <code>type</code>
</li>
      <li>
<code>node.kind</code> (tree_stump) → unified <code>type</code>
</li>
      <li>
<code>node.start_point</code> → unified <code>start_point</code> (returns hash)</li>
      <li>
<code>node.start_position</code> → unified <code>start_point</code> (returns hash)</li>
      <li>
<code>node.is_named?</code> (tree_stump) → unified <code>named?</code>
</li>
      <li>
<code>node.named?</code> (ruby_tree_sitter) → unified <code>named?</code>
</li>
    </ul>
  </li>
</ul>

<h3 id="2-treehavertree-new-file">2. TreeHaver::Tree (new file)</h3>
<ul>
  <li>Wraps backend-specific tree objects</li>
  <li>Returns wrapped <code>TreeHaver::Node</code> from <code>root_node</code>
</li>
  <li>Stores source text for text extraction</li>
</ul>

<h3 id="3-updated-all-backends">3. Updated All Backends</h3>

<p><strong>MRI Backend (<code>backends/mri.rb</code>):</strong></p>
<pre class="code language-ruby"><code class="language-ruby">def parse(source)
  tree = @parser.parse(source)
  TreeHaver::Tree.new(tree, source: source)  # Now wraps!
end
</code></pre>

<p><strong>Rust Backend (<code>backends/rust.rb</code>):</strong></p>
<pre class="code language-ruby"><code class="language-ruby">def parse(source)
  tree = @parser.parse(source)
  TreeHaver::Tree.new(tree, source: source)  # Now wraps!
end
</code></pre>

<p><strong>FFI Backend (<code>backends/ffi.rb</code>):</strong></p>
<pre class="code language-ruby"><code class="language-ruby">def parse(source)
  tree_ptr = Native.ts_parser_parse_string(@parser, ::FFI::Pointer::NULL, src, src.bytesize)
  inner_tree = Tree.new(tree_ptr)
  TreeHaver::Tree.new(inner_tree, source: src)  # Now wraps!
end
</code></pre>

<p><strong>Java Backend (<code>backends/java.rb</code>):</strong></p>
<pre class="code language-ruby"><code class="language-ruby">def parse(source)
  java_tree = @parser.parse(source)
  inner_tree = Tree.new(java_tree)
  TreeHaver::Tree.new(inner_tree, source: source)  # Now wraps!
end
</code></pre>

<h2 id="api-provided-by-treehavernode">API Provided by TreeHaver::Node</h2>

<pre class="code language-ruby"><code class="language-ruby"># Type information
node.type          # String - works across all backends

# Position (bytes)
node.start_byte    # Integer
node.end_byte      # Integer

# Position (row/column)  
node.start_point   # { row: Integer, column: Integer }
node.end_point     # { row: Integer, column: Integer }

# Text
node.text          # String - extracted from source

# Hierarchy
node.child_count   # Integer
node.child(index)  # TreeHaver::Node
node.children      # Array&lt;TreeHaver::Node&gt;
node.named_children # Array&lt;TreeHaver::Node&gt;
node.parent        # TreeHaver::Node | nil
node.next_sibling  # TreeHaver::Node | nil
node.prev_sibling  # TreeHaver::Node | nil

# Fields (tree-sitter feature)
node.field(name)   # TreeHaver::Node | nil

# Status
node.has_error?    # Boolean
node.missing?      # Boolean  
node.named?        # Boolean

# Iteration
node.each { |child| ... }  # Yields TreeHaver::Node
</code></pre>

<h2 id="benefits">Benefits</h2>

<h3 id="1-true-portability">1. True Portability</h3>
<p>Code using TreeHaver now works identically across:</p>
<ul>
  <li>MRI (ruby_tree_sitter)</li>
  <li>MRI (tree_stump/Rust)</li>
  <li>JRuby (FFI)</li>
  <li>JRuby (java-tree-sitter)</li>
  <li>TruffleRuby (FFI)</li>
</ul>

<h3 id="2-no-backend-specific-code">2. No Backend-Specific Code</h3>
<p>Applications like toml-merge don’t need to know which backend is used:</p>

<pre class="code language-ruby"><code class="language-ruby"># This works with ANY backend!
parser = TreeHaver::Parser.new
parser.language = TreeHaver::Language.toml
tree = parser.parse(source)

node = tree.root_node
puts node.type          # Works!
puts node.start_byte    # Works!
node.children.each { |child| puts child.type }  # Works!
</code></pre>

<h3 id="3-consistent-testing">3. Consistent Testing</h3>
<p>Test suites can test once and know it works everywhere:</p>

<pre class="code language-ruby"><code class="language-ruby"># Same test works for all backends
RSpec.shared_examples &quot;tree-sitter backend&quot; do
  it &quot;parses TOML correctly&quot; do
    tree = parser.parse(&quot;[section]\nkey = &#39;value&#39;&quot;)
    root = tree.root_node
    
    expect(root.type).to eq(&quot;document&quot;)
    expect(root.children.size).to be &gt; 0
  end
end
</code></pre>

<h3 id="4-future-proof">4. Future-Proof</h3>
<p>New backends can be added without breaking existing code:</p>
<ul>
  <li>Just implement backend-specific internals</li>
  <li>Return TreeHaver::Tree from parse()</li>
  <li>Everything else works automatically!</li>
</ul>

<h2 id="files-modified">Files Modified</h2>

<ol>
  <li>✅ <code>tree_haver/lib/tree_haver.rb</code> - Added Node and Tree autoloads</li>
  <li>✅ <code>tree_haver/lib/tree_haver/node.rb</code> - NEW: Unified Node wrapper</li>
  <li>✅ <code>tree_haver/lib/tree_haver/tree.rb</code> - NEW: Unified Tree wrapper</li>
  <li>✅ <code>tree_haver/lib/tree_haver/backends/mri.rb</code> - Returns wrapped Tree</li>
  <li>✅ <code>tree_haver/lib/tree_haver/backends/rust.rb</code> - Returns wrapped Tree</li>
  <li>✅ <code>tree_haver/lib/tree_haver/backends/ffi.rb</code> - Returns wrapped Tree</li>
  <li>✅ <code>tree_haver/lib/tree_haver/backends/java.rb</code> - Returns wrapped Tree</li>
</ol>

<h2 id="testing-status">Testing Status</h2>

<p>Running tests to verify the fix works with TreeStump backend…</p>

<h2 id="next-steps">Next Steps</h2>

<ol>
  <li>✅ <strong>DONE</strong>: Fix TreeHaver to provide unified API</li>
  <li>
<strong>TODO</strong>: Verify tests pass with TreeStump backend</li>
  <li>
<strong>TODO</strong>: Complete toml-merge refactor to use TreeHaver</li>
  <li>
<strong>TODO</strong>: Add Citrus backend to TreeHaver (Phase 2)</li>
</ol>

<h2 id="impact-on-toml-merge">Impact on toml-merge</h2>

<p>toml-merge now gets TreeHaver::Node objects which have a consistent API:</p>
<ul>
  <li>No more <code>TreeStump::Node</code> vs <code>TreeSitter::Node</code> differences</li>
  <li>
<code>node.type</code> works consistently (not <code>node.kind</code> sometimes)</li>
  <li>All position methods work the same way</li>
  <li>Iteration works the same way</li>
</ul>

<p>The test failure should now be fixed because <code>TreeHaver::Node</code> has a <code>type</code> method that works with all backends!</p>
</div></div>

      <div id="footer">
  Generated on Fri Jan  9 01:13:01 2026 by
  <a href="https://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.38 (ruby-4.0.0).
</div>

    </div>
  </body>
</html>